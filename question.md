# 遇到的一些问题
这里的问题是我写这个小网站时遇到的一些问题, 如果关于这些问题你有自己的见解, 请抽出点时间告诉我, 我的邮箱是 [i.am.t.lbk@gmail.com](mailto:i.am.t.lbk@gmail.com).

## 关于软件分模块
软件怎样分模块才合适? 像这个小测试网站这样, 由于spring**貌似**只能有一个加载资源文件的bean, 导致所有需要测试persist模块的地方都得配置加载的文件.这既是好事也是坏事:

- 好事就是配置性更强: 向questionnaire-sms中的`git.lbk.questionnaire.sms.SmsImplParallelTest`测试类中我想使用h2database, 直接创建一个测试的配置文件, 里面写上h2database数据库的信息就可以.
- 坏事就是依赖太强了吧? 这里所有需要使用这个模块的地方都需要去加载那个资源文件.而且需要准确的配置上加密的属性名...

那么软件怎么分模块更合适呢?

- 用户相关的在一个模块, 其他的根据情况分几个模块, 然后各个模块之间使用包进行分层?
- 页面相关在一个模块, 业务层在一个模块?
- 不分模块, 直接写. 个人感觉在写小型程序(可能也包含部分中型程序吧)时非常方便, 快速, 就像脚本语言在处理简单事情时几行代码就能搞定, 省时省事. 可是在处理比较大的程序时就有点混乱了吧.

这个, 我还没有写过中/大型程序, 所以这些都只是 听说 + 感觉. 这里算是练习一下模块吧, 可是反而发现更多问题...

## 关于 XML 和 Annotation 配置方法
其实我很喜欢Annotation配置, 简单, 便捷, 貌似还比XML清晰. 但是这里Spring Bean的配置我几乎使用的都是XML文件, 因为有一个问题解决不了:
比如我在dao层中使用了Annotation进行配置, 而且测试时很可能需要修改部分配置项, 那么可以这样做:

- 修改Annotation配置.
    - 这样做的问题在于, 每次测试都需要修改配置, 测试完了, 还得修改过来...
- 创建一个新的XML配置文件, 并且不配置自动扫描的包.
    - 那就相当于又重新写了一份配置.
    - 而且从测试的角度看, 那几个dao层的类, 既有Annotation配置(虽然并没有使用), 又有XML配置, 感觉有点丑陋.
- 把可能变化的部分抽出来, 写在XML中, 其他部分写成Annotation配置.
    - 不同的测试可能有不同的部分有变化. 最终可能是, 所有的部分都得修改.
    - 最重要的一点是, 感觉这样比上面那种更丑陋.

或者说Annotation的问题在于无法存在多份配置, 然后在程序运行时去选择使用哪份配置. 而Annotation既然存在, 而且貌似很火(可能是我太喜欢这种配置方式了吧), 那么实际使用时是怎么解决这个问题的呢?

## 关于测试的独立性
我觉得测试的独立性挺重要的, 虽然有时候也需要一些依赖吧. 最开始, 测试`UerDaoImpl`时由于测试删除方法时把数据删了, 导致后面的更新, 查新等都出现了错误. 所以我就专门加了一两条用于测试的数据, 测试删除时只删这两条, 更新等操作操作其他数据. 但是随着需要测试的东西变多, 慢慢有点乱了. 比如这次测试调查相关. 由于一部分调查会被删除, 所以在插入Page表的数据时只能再专门插入几条调查相关的数据, 不然Page的外键不太好处理. 结果就是现在的`test-data.sql`(`questionnaire-persist`模块中)文件很乱. 连我自己都不知道哪些数据能删, 哪些不能删. 那么, 有没有办法去组织这些测试数据, 增加每个测试之间的独立性. 在测试文件中添加足够的注释行吗? 或者每个测试都重新加载数据文件?

## 关于墨忒耳律
这又是一个因为测试引起的问题...

现在我觉得墨忒耳律可能, 应该是正确的了(好吧, 我以前确实觉得墨忒耳律是在难为人). 因为我发现一个问题:
我的代码大部分都非常不好测试, 比如`git.lbk.questionnaire.statistics.QuestionStatisticsFactory`的
`createSurveyStatistics`方法:
 - 要想测试`createSurveyStatistics`就得创建一个`Survey`对象.
 - 查看方法的代码就会发现需要用到`Survey.getPages`方法. 那就需要创建一些`Page`对象传到`Survey`对象中.
 - 然后又需要创建一些`Question`对象传到`Page`对象中.
 - `Question`对象中还需要添加一些选项

这样, 为了测试, 初始化代码就需要几十行. 太不方便了. 那么, 怎么做, 才能让代码尽可能的符合墨忒耳律呢? 或者即使代码不符合墨忒耳律也能非常方便的测试呢?

## 关于日志
在做防止重复提交功能时, 我大致翻了一下struts中相关部分的代码. 然后发现里面日志部分的代码大致如下:
```java
if (LOG.isWarnEnabled()) {
    LOG.warn("Could not find token mapped to token name " + tokenName);
}
```
也就是先测试是否启用了相应等级的日志级别, 然后在输出. 但是为什么要这样做呢? 不可以直接输出吗? 反正只要不启用, 跟没输出效果一样. 难道是效率问题吗? 可是我大致查看了一下源码(我用的是logback, 所以看得是`ch.qos.logback.classic.Logger`的源码), 输出日志前也经过大致相同的判断, 所以应该并没有效率上的问题啊. 反而, 如果相应等级的日志级别已经启用, 那么就会判断两次...

## 关于entity中的属性
这个问题确实有点钻牛角尖...所以我放到最后了. 但是我还是想知道. entity就是为了保存, 传递数据用的, 那么为什么还有将属性的可见性设为`private`, 然后再提供`getter`, `setter`呢? 直接设为`public`不是更简洁吗? 确实由于JavaBean的实现, 框架可能都是使用`getter`, `setter`获取设置属性的. 所以没有`gettet`和`setter`时, 使用框架时应该会出问题. 但是除去这些历史原因, 还有没有其他的原因? 貌似属性设置成`private`也没有使程序更易修改啊: 修改属性的时候, 通常都会修改相应的`getter`, `setter`吧? 那所有使用`getter`, `setter`的地方不也同样的跟着改吗?
