# 遇到的一些问题
这里的问题是我写这个小网站时遇到的一些问题, 如果关于这些问题你有自己的见解, 请抽出点时间告诉我, 我的邮箱是 [i.am.t.lbk@gmail.com](mailto:i.am.t.lbk@gmail.com).

## 关于软件分模块
软件怎么分模块更合适呢?

- 用户相关的在一个模块, 其他的根据情况分几个模块, 然后各个模块之间使用包进行分层?
- 页面相关在一个模块, 业务层在一个模块?
- 不分模块, 直接写. 个人感觉在写小型程序(可能也包含部分中型程序吧)时非常方便, 快速, 就像脚本语言在处理简单事情时几行代码就能搞定, 省时省事. 可是在处理比较大的程序时就有点混乱了吧.

这个, 我还没有写过中/大型程序, 所以这些都只是 听说 + 感觉. 这里算是练习一下模块吧, 可是反而发现更多问题...

## 关于测试的独立性
我觉得测试的独立性挺重要的, 虽然有时候也需要一些依赖吧. 最开始, 测试`UerDaoImpl`时由于测试删除方法时把数据删了, 导致后面的更新, 查新等都出现了错误. 所以我就专门加了一两条用于测试的数据, 测试删除时只删这两条, 更新等操作操作其他数据. 但是随着需要测试的东西变多, 慢慢有点乱了. 比如这次测试调查相关. 由于一部分调查会被删除, 所以在插入Page表的数据时只能再专门插入几条调查相关的数据, 不然Page的外键不太好处理. 结果就是现在的`test-data.sql`(`questionnaire-persist`模块中)文件很乱. 连我自己都不知道哪些数据能删, 哪些不能删. 那么, 有没有办法去组织这些测试数据, 增加每个测试之间的独立性. 在测试文件中添加足够的注释行吗? 或者每个测试都重新加载数据文件?

## 关于墨忒耳律
这又是一个因为测试引起的问题...

现在我觉得墨忒耳律可能, 应该是正确的了(好吧, 我以前确实觉得墨忒耳律是在难为人). 因为我发现一个问题:
我的代码大部分都非常不好测试, 比如`git.lbk.questionnaire.statistics.QuestionStatisticsFactory`的
`createSurveyStatistics`方法:
 - 要想测试`createSurveyStatistics`就得创建一个`Survey`对象.
 - 查看方法的代码就会发现需要用到`Survey.getPages`方法. 那就需要创建一些`Page`对象传到`Survey`对象中.
 - 然后又需要创建一些`Question`对象传到`Page`对象中.
 - `Question`对象中还需要添加一些选项

这样, 为了测试, 初始化代码就需要几十行. 太不方便了. 那么, 怎么做, 才能让代码尽可能的符合墨忒耳律呢? 或者即使代码不符合墨忒耳律也能非常方便的测试呢?

## 关于日志
在做防止重复提交功能时, 我大致翻了一下struts中相关部分的代码. 然后发现里面日志部分的代码大致如下:
```java
if (LOG.isWarnEnabled()) {
    LOG.warn("Could not find token mapped to token name " + tokenName);
}
```
也就是先测试是否启用了相应等级的日志级别, 然后在输出. 但是为什么要这样做呢? 不可以直接输出吗? 反正只要不启用, 跟没输出效果一样. 难道是效率问题吗? 可是我大致查看了一下源码(我用的是logback, 所以看得是`ch.qos.logback.classic.Logger`的源码), 输出日志前也经过大致相同的判断, 所以应该并没有效率上的问题啊. 反而, 如果相应等级的日志级别已经启用, 那么就会判断两次...

## AOP记录日志
日志适合用AOP记录吗? 如果适合, 应该在哪层记录呢?
在service层记录得到的数据离错误更近. 可能会更容易获得错误原因. 但是不好得到是谁操作的, 还有原始的请求参数.
在controller中记录离错误更远, 正相反, 容易获取原始数据, 但是如果日志是存到数据库, 那么事务就得一直开着, 直到请求结束.

还有就是错误的日志是记录到数据库呢? 还是某个文件中呢?
记录到数据库的可以根据列非常容易的获取到日志的各个部分. 但是如果发生错误, 本身就有可能是因为数据库发生错误了: 过载了, 网络问题等, 再向数据库加数据有可能会使问题加剧.
而记录到文件中, 那么取出日志时, 想提取出指定的部分(比如, 请求参数)就没有数据库容易了.

## 关于entity中的属性
这个问题确实有点钻牛角尖...所以我放到最后了. 但是我还是想知道. entity就是为了保存, 传递数据用的, 那么为什么还有将属性的可见性设为`private`, 然后再提供`getter`, `setter`呢? 直接设为`public`不是更简洁吗? 确实由于JavaBean的实现, 框架可能都是使用`getter`, `setter`获取设置属性的. 所以没有`gettet`和`setter`时, 使用框架时应该会出问题. 但是除去这些历史原因, 还有没有其他的原因? 貌似属性设置成`private`也没有使程序更易修改啊: 修改属性的时候, 通常都会修改相应的`getter`, `setter`吧? 那所有使用`getter`, `setter`的地方不也同样的跟着改吗?
